function [solverOutput] = gTDE_EUSIPCO(PCCC, microphones, samplingPeriod, x0)

% gXCE geometric-constrained time difference estimation
% 
%     TDE = gTDE(sigPCCC, microphones, samplingPeriod, x0, verbose)
%     Estimates the time difference of signals (or their Polynomial 
%     Coefficients Cross-Correlation) acquired by microphones 
%     sampled at samplingPeriod. The method is based on a geometric-
%     constrained maximization of the continuous estimation of the cross-
%     correlation functions. 'signals' is a M-by-N matrix with one row per 
%     acquired signal. 'microphoned' is a M-by-3 matrix with one row per 
%     microphone's position. TDE is a M(M-1)/2 vector with the TDEs. 
%
%     The reference microphone will be the first one, although this 
%     should not matter.
%
%     see also gTDESSL, PolynomialInterpolationCoefficients,
%     PolynomialCoefficientsCrossCorrelation
    
    %%% Input check
    if nargin < 4
        error('Usage TDE = gTDE(signals, microphones, samplingPeriod, x0[, verbose])');
    end
    if size(PCCC,1) ~= size(microphones,1)
        error('There should be as many signals as microphones.');
    end
    if size(microphones,2) ~= 3 && size(microphones,2) ~= 2
        error('The system works in 2D or in 3D.');
    end
    if samplingPeriod <= 0
        error('The sampling period should be positive.');
    end
    
    %%% General variables
    % Number of microphones
    NMics = size(microphones,1);
    % Maximum TDE values from the microphones
    maxTDE = TDEmax(microphones)/samplingPeriod;
    
    % Declare the objective function
    objFunction = @(x) gTDECriterionEUSIPCO(x,PCCC,microphones,samplingPeriod);
    consFunction = @(x,z) constraints(x,z,microphones,samplingPeriod);
%     hessFunction = @(x,lambda) gTDEHessianFunction(x,lambda,PCCC,microphones,samplingPeriod,true);
    
    % if verbose, declare verbose options
%     if verbose
%         options = optimset('GradObj','on',...
%                            'GradConstr','on',...
%                            'Hessian','user-supplied',...
%                            'Algorithm','interior-point',...
%                            'DerivativeCheck','on',...
%                            'HessFcn',hessFunction,...
%                            'TolX',1e-14,...
%                            'TolFun',1e-8,...
%                            'PlotFcns',{...
%                                @optimplotx,...
%                                @optimplotfunccount,...
%                                @optimplotfval,...
%                                @optimplotconstrviolation,...
%                                @optimplotstepsize,...
%                                @optimplotfirstorderopt...
%                                @myPlotFunction...                                   
%                                },...
%                            'Display','on'...
%                            );        
%     else
%         options = optimset('GradObj','on',...
%                            'GradConstr','on',...
%                            'Hessian','user-supplied',...
%                            'Algorithm','interior-point',...
%                            'HessFcn',hessFunction,...
%                            'TolX',1e-14,...
%                            'TolFun',1e-8,...
%                            'MaxIter',10,...
%                            'Display','off'...
%                            );
%     end

    % Run the optimization method
%     [TDE fVal] = My_fmincon(objFunction, x0,...
%                                   [], [], [], [],...
%                                   -maxTDE(1:NMics-1), maxTDE(1:NMics-1),... 
%                                   consFunction,...
%                                   options);
    [TDE, fVal, cVal] = ipsolver_parallelEUSIPCO(x0,objFunction,consFunction,'newton',1e-8,15,false);
    
    % Set output
    solverOutput.x = TDE;
    solverOutput.f = fVal;
    solverOutput.c = cVal;
end

function [c, J, W] = constraints(TDEs,z,microphones,samplingPeriod)
    % Compute the restriction (is a positive restriction)
    [c, J, W] = TDEDiscriminant(TDEs,microphones,samplingPeriod);
    % Change the sign of the restriction and its gradient, and set the
    % equatlity constratints to null
    c = -c;
    % The computed J is the gradient, and the solver expects the
    % Jacobian...
    J = -J;
    if ~isempty(z)
        W = -z(1)*W;
    end
end
